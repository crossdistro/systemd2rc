#!/usr/bin/python3

# Copyright (c) 2014, Pavel Å imerda <pavlix@pavlix.net>
# All rights reserved.
# 
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met: 
# 
# 1. Redistributions of source code must retain the above copyright notice, this
#    list of conditions and the following disclaimer. 
# 2. Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution. 
# 
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
# ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
# 
# The views and conclusions contained in the software and documentation are those
# of the authors and should not be interpreted as representing official policies, 
# either expressed or implied, of the FreeBSD Project.

import os, sys

HEADER = """\
#!/sbin/runscript
#
# Generated by systemd2openrc from {path}
#
# Description: {description}
"""

MAIN = """\
start() {{
    ebegin "Starting $SVCNAME"
{output_start_pre}\
    start-stop-daemon --start $STARTOPTS --pidfile "$PIDFILE" -- $COMMAND || error
{output_start_post}\
    eend 0
}}

stop() {{
    ebegin "Stopping $SVCNAME"
{output_stop_pre}\
    start-stop-daemon --stop $STOPOPTS --pidfile "$PIDFILE"
{output_stop_post}\
    eend 0
}}

reload() {{
    ebegin "Reloading $SVCNAME"
    start-stop-daemon --signal HUP --pidfile "$PIDFILE" || error
}}

error() {{
    eend 1
    exit 1
}}
"""

TRANSFORM_SERVICE = {
    'network.target': 'net',
}

class Convertor:
    def __init__(self, path, pidfile=None):
        self.description = ""
        self.deps = []
        self.path = path
        self.name = os.path.split(self.path)[1].split('.')[0]
        self.pidfile = pidfile or "/run/{}.pid".format(self.name)
        self.commands = []
        self.start_pre = []
        self.start_post = []
        self.stop_pre = []
        self.stop_post = []
        self.unsupported = []
        self.unsupported_deps = []
        self.service_type = "simple"

        section = None

        with open(self.path) as stream:
            for line in stream:
                if line.startswith('['):
                    section = line.strip('[] \t\r\n')
                elif '=' in line:
                    option, value = (s.strip() for s in line.split('=', 2))
                    try:
                        func = getattr(self, "process_{}_{}".format(section, option))
                    except AttributeError:
                        self.unsupported.append((section, option, value))
                        continue
                    func(value)

    def __str__(self):
        self.output_start_pre = "".join(self.make_command(command) for command in self.start_pre)
        self.output_start_post = "".join(self.make_command(command) for command in self.start_post)
        self.output_stop_pre = "".join(self.make_command(command) for command in self.stop_pre)
        self.output_stop_post = "".join(self.make_command(command) for command in self.stop_post)

        data = vars(self)

        output = [HEADER.format(**data)]
        output += ["#\n# Unsupported systemd options:\n"] + ["#     {}.{} = {}\n".format(*item) for item in self.unsupported]
        output += ["#\n# Unsupported dependencies:\n"] + ["#     {} {}\n".format(*item) for item in self.unsupported_deps]
        output += getattr(self, "output_variables_{}".format(self.service_type))()
        if self.deps:
            output += ["\ndepend() {\n"] + ["    {} {}\n".format(*item) for item in self.deps] + ["}\n\n"]
        output += getattr(self, "output_main_{}".format(self.service_type))()

        return "".join(output)

    def make_command(self, command):
        if command.startswith('-'):
            return "    {}\n".format(command[1:])
        else:
            return "    {} || error\n".format(command)

    def output_variables_simple(self):
        yield '\n'
        yield 'COMMAND="{}"\n'.format(self.commands[0])
        yield 'PIDFILE="{}"\n'.format(self.pidfile)
        yield 'STARTOPTS="--start --make-pidfile --background --quiet"\n'
        yield 'STOPOPTS="--quiet"\n'

    def output_variables_forking(self):
        yield '\n'
        yield 'COMMAND="{}"\n'.format(self.commands[0])
        yield 'PIDFILE="{}"\n'.format(self.pidfile)
        yield 'STARTOPTS=""\n'
        yield 'STOPOPTS=""\n'

    def output_variables_oneshot(self):
        return []

    def output_main_simple(self):
        yield MAIN.format(**vars(self))
    output_main_forking = output_main_simple

    def output_main_oneshot(self):
        if self.commands:
            yield '\nstart() {\n    ebegin "Starting $SVCNAME"\n'
            for command in self.commands:
                yield self.make_command(command)
            yield '    eend 0\n}\n'
        if False:
            yield '\nstop() {\n'
            yield '}\n'

    # Treat dbus services as simple
    output_variables_dbus = output_variables_simple
    output_main_dbus = output_main_simple

    def add_dependency(self, how, services):
        for service in services.split():
            try:
                self.deps.append((how, TRANSFORM_SERVICE[service]))
            except KeyError:
                if service.endswith('.service'):
                    self.deps.append((how, service[:-8]))
                elif '.' in service:
                    self.unsupported_deps.append((how, service))
                else:
                    self.deps.append((how, service))

    def process_Unit_Description(self, value):
        self.description = value

    def process_Unit_Before(self, value):
        self.add_dependency("before", value)

    def process_Unit_After(self, value):
        self.add_dependency("after", value)

    def process_Unit_Wants(self, value):
        self.add_dependency("need", value)

    def process_Unit_Requires(self, value):
        self.add_dependency("need", value)

    def process_Service_Type(self, value):
        self.service_type = value

    def process_Service_ExecStart(self, value):
        self.commands.append(value)

    def process_Service_ExecStartPre(self, value):
        self.start_pre.append(value)

    def process_Service_ExecStartPost(self, value):
        self.start_post.append(value)

    def process_Service_ExecStopPre(self, value):
        self.stop_pre.append(value)

    def process_Service_ExecStopPost(self, value):
        self.stop_post.append(value)

def read_kargs(argv):
    kargs = {}
    sys.argv.pop(0)
    while sys.argv:
        if sys.argv[0] == '--pidfile':
            sys.argv.pop(0)
            kargs['pidfile'] = sys.argv.pop(0)
        else:
            kargs['path'] = sys.argv.pop(0)
    return kargs

if __name__ == '__main__':
    sys.stdout.write(str(Convertor(**read_kargs(sys.argv))))
